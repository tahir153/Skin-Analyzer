# -*- coding: utf-8 -*-
"""Dermnet3Classes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10NUNfe4T2VDPli2hYPKkDR9_E0TnSZt0
"""

import os
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import cv2

from tensorflow.keras.preprocessing.image import ImageDataGenerator, img_to_array, load_img
from tensorflow.keras.preprocessing import image

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive

# !pip install -q kaggle
# ! mkdir ~/.kaggle
# !cp /content/drive/MyDrive/kaggle.json ~/.kaggle/kaggle.json
# ! chmod 600 ~/.kaggle/kaggle.json
# ! kaggle datasets download shubhamgoel27/dermnet
# !unzip /content/drive/MyDrive/dermnet.zip -d /content/drive/MyDrive/dermnet

import os

test_list=os.listdir('dermnet/test') 

train_list=os.listdir('dermnet/train')

train_list.sort()
test_list.sort()

print(train_list)

subset_data = ['Acne and Rosacea Photos', 'Actinic Keratosis Basal Cell Carcinoma and other Malignant Lesions', 'Atopic Dermatitis Photos']
len(subset_data)

def data_dictionary():
    path_train="dermnet/train/"
    path_test="dermnet/test/"
    train_dictionary={"image_path":[],"target":[]}
    test_dictionary={"image_path":[],"target":[]}
    label=0
    for i in subset_data:
        path_disease_train=path_train+i
        path_disease_test=path_test+i
        image_list_train=os.listdir(path_disease_train)
        image_list_test=os.listdir(path_disease_test)
        for j in image_list_train:
            img_path_train=path_disease_train+"/"+j
            train_dictionary["image_path"].append(img_path_train)
            train_dictionary['target'].append(label)
        for m in image_list_test:
            img_path_test=path_disease_test+"/"+m
            test_dictionary["image_path"].append(img_path_test)
            test_dictionary['target'].append(label)
        label+=1 
    test_df=pd.DataFrame(test_dictionary)
    train_df=pd.DataFrame(train_dictionary)
        
    return  train_df,test_df

import pandas as pd
import numpy as np
import cv2

def load_data(input_size):
    xtrain_images=[]
    xtest_images=[]
    train_df,test_df=data_dictionary()
    for i in train_df['image_path']:
        # img=cv2.imread(i)
        # img=cv2.resize(img,input_size)
        # cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        img = load_img(i, target_size = input_size)
        img = img_to_array(img)
        xtrain_images.append(img)
    y_train=np.asarray(train_df['target'])
    x_train=np.asarray(xtrain_images)
    for j in test_df['image_path']:
        img = load_img(j, target_size = input_size)
        img = img_to_array(img)
        xtest_images.append(img)
    y_test=np.asarray(test_df['target'])
    x_test=np.asarray(xtest_images)
    return x_train,x_test,y_train,y_test

x_train,x_test,y_train,y_test=load_data(input_size=(224, 224))

# from sklearn.model_selection import train_test_split
# X_train, X_valid, Y_train, Y_valid = train_test_split(x_train,y_train, test_size = 0.1)

print(x_train.shape)
print(y_train.shape)
print(x_test.shape)
print(y_test.shape)

import tensorflow as tf

from tensorflow.keras.utils import to_categorical
ytrain = to_categorical(y_train, 3)
ytest = to_categorical(y_test,3)

# import time
# from keras.callbacks import ModelCheckpoint, EarlyStopping
batch_size = 32

train_datagen = ImageDataGenerator(rescale = 1./255,
        rotation_range=10,  
        zoom_range = 0.1, 
        width_shift_range=0.1,
        height_shift_range=0.1,  
        horizontal_flip=True)

test_datagen = ImageDataGenerator(rescale = 1./255)

train_generator = train_datagen.flow(
    x_train,ytrain,
    batch_size=batch_size)

validation_generator = test_datagen.flow(
    x_test,ytest,
    batch_size=batch_size)

from tensorflow import keras
from tensorflow.keras import layers, models
from keras.layers import Conv2D, MaxPooling2D, Dense, Flatten, Dropout

model = models.Sequential()
model.add(Conv2D(32, (3, 3), activation='relu', input_shape=(224, 224, 3)))
model.add(MaxPooling2D((2, 2)))
model.add(Conv2D(64, (3, 3), activation='relu'))
model.add(MaxPooling2D((2, 2)))
model.add(Conv2D(128, (3, 3), activation='relu'))
model.add(MaxPooling2D((2, 2)))
model.add(Flatten())
model.add(Dense(128, activation='relu'))
model.add(Dense(3, activation='softmax'))

x_train.shape

from keras.optimizers import RMSprop

optimizer = RMSprop(lr=0.001, rho=0.9, epsilon=1e-08, decay=0.0)

model.compile(optimizer, loss='categorical_crossentropy', metrics=['accuracy'])

# learning_rate_reduction=ReduceLROnPlateau(monitor='val_accuracy', patience = 3, verbose = 1, factor = 0.5, minlr = 0.00001)

history=model.fit(train_generator,
                            epochs=20,
                            validation_data = validation_generator,
                            verbose=1,
                            steps_per_epoch=len(x_train) // batch_size,
                            validation_steps=len(x_test) //batch_size) 
                            # callbacks=[checkpointer, learning_rate_reduction])

model.save("SkinDiseasePrediction.h5")

plt.subplot(2, 2, 1)
plt.plot(history.history['accuracy'], label='accuracy')
plt.plot(history.history['val_accuracy'], label='val_accuracy')
plt.title('Accuracy Function Evolution')
plt.legend()

plt.subplot(2, 2, 2)
plt.plot(history.history['loss'], label='loss')
plt.plot(history.history['val_loss'], label='val_loss')
plt.title('Loss Function Evolution')
plt.legend()

import tensorflow as tf
modal = tf.keras.models.load_model("/content/drive/MyDrive/SkinDiseasePrediction.h5")

pred = modal.predict(x_test)

from sklearn.metrics import accuracy_score
score = modal.evaluate(x_test, ytest, verbose = 0)

xtest = x_test/255
score1 = modal.evaluate(xtest, ytest, verbose = 0)

score1
